## 課題：ヴィジュネル暗号の解読 📜

### 概要

カエサル暗号を拡張した古典的な暗号である「ヴィジュネル暗号」を実装してください。平文と「鍵」となる文字列を受け取り、暗号化・復号する関数を作成します。

---

### ヴィジュネル暗号の仕組み

ヴィジュネル暗号は、1つの決まった数で文字をずらすカエサル暗号とは異なり、**「鍵」となる単語**を使って、ずらす数を文字ごとに変化させる、より強力な暗号です。

#### 例：平文「ATTACK」を鍵「key」で暗号化する場合

**1. 鍵を繰り返す**
まず、平文の長さに合わせて、鍵を繰り返します。

| 平文 | A | T | T | A | C | K |
| :--- | :-: | :-: | :-: | :-: | :-: | :-: |
| **繰り返し鍵** | k | e | y | k | e | y |

**2. 文字を数字に変換する (a=0, b=1, ..., z=25)**
次に、平文と鍵の各文字を、アルファベット順に対応する数字に変換します。大文字も小文字も、計算時は同じ数字として扱います。（A=0, a=0）

| | A | T | T | A | C | K |
| :--- | :-: | :-: | :-: | :-: | :-: | :-: |
| 平文の数字 | 0 | 19 | 19 | 0 | 2 | 10 |
| 鍵の数字 | 10 | 4 | 24 | 10 | 4 | 24 |

**3. 平文と鍵の数字を足し算する**
対応する数字同士を足し算します。合計が26以上になった場合は、26を引いてアルファベットが循環するようにします（プログラミングでは `(合計) % 26` で計算できます）。

| | A | T | T | A | C | K |
| :--- | :-: | :-: | :-: | :-: | :-: | :-: |
| 平文の数字 | 0 | 19 | 19 | 0 | 2 | 10 |
| 鍵の数字 | 10 | 4 | 24 | 10 | 4 | 24 |
| **(平文+鍵)%26** | **10** | **23** | **17** | **10** | **6** | **8** |

**4. 数字を文字に戻す**
最後に、計算結果の数字を再びアルファベットに戻します。このとき、元の平文が大文字なら大文字に、小文字なら小文字に戻します。

| | A | T | T | A | C | K |
| :--- | :-: | :-: | :-: | :-: | :-: | :-: |
| ... | ... | ... | ... | ... | ... | ... |
| (平文+鍵)%26 | 10 | 23 | 17 | 10 | 6 | 8 |
| **暗号文** | **K** | **X** | **R** | **K** | **G** | **I** |

これにより、平文「`ATTACK`」は暗号文「`KXRKGI`」に変換されます。

**復号**はこの逆の操作で、暗号文の数字から鍵の数字を**引き算**します。

---

### あなたのミッション

提供される `main` 関数を完成させ、引数で渡された文字列 (`text`) と鍵 (`key`) を使って、ヴィジュネル暗号の暗号化、または復号を行ってください。処理のモードは `mode` 引数によって切り替えます。

#### 実装すべきルール

1.  **大文字と小文字の維持**:
    * 平文の大文字は、暗号化後も大文字を維持します。（例: `H` → `R`）
    * 平文の小文字は、暗号化後も小文字を維持します。（例: `e` → `i`）

2.  **アルファベット以外の文字の扱い**:
    数字、記号、スペースなどのアルファベット以外の文字は、暗号化（または復号）せず、**そのままの位置に維持**します。
    **重要な点として、鍵の文字はアルファベット以外の文字では消費されず、次のアルファベット文字のために待機します。**

    ##### 具体例: 平文 `Hello World!` と 鍵 `key`
    以下の表のように、平文の ` ` (スペース) と `!` (感嘆符) の箇所では、鍵の文字は進んでいません。`o` の次のアルファベットである `W` には、`o` で使われた鍵 `e` の次の `y` が適用されます。

    | 平文 | H | e | l | l | o | | W | o | r | l | d | ! |
    | :--- | :-: | :-: | :-: | :-: | :-: | :---: | :-: | :-: | :-: | :-: | :-: | :---: |
    | **適用する鍵** | k | e | y | k | e | **(消費しない)** | y | k | e | y | k | **(消費しない)** |

3.  **復号**:
    `mode`が`decrypt`の場合、暗号化とは逆の引き算のロジックを実装してください。

### 入出力の仕様

* **入力**:
    * `text: string`: 暗号化または復号したい文字列。
    * `key: string`: 暗号化に使用する、**小文字のアルファベットのみ**で構成された鍵。
    * `mode: 'encrypt' | 'decrypt'`: `'encrypt'`（暗号化）または `'decrypt'`（復号）を指定します。
* **出力**: `string`
    * 処理後の文字列。

---

### 実装例

```javascript
// 暗号化の例
main('Hello World!', 'key', 'encrypt') 
// 'Rijvs Uyvjn!' を返す

main('ATTACK AT DAWN', 'lemon', 'encrypt')
// 'LXFOPV EF RNHR' を返す

// 復号の例
main('Rijvs Uyvjn!', 'key', 'decrypt')
// 'Hello World!' を返す

main('LXFOPV EF RNHR', 'lemon', 'decrypt')
// 'ATTACK AT DAWN' を返す